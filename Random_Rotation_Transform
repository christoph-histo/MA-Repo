import torch
import torchio as tio
import numpy as np

class RandomRotation3D(tio.Transform):
    def __init__(self, p=1.0, **kwargs):
        """Invert the intensity of the image with a given probability."""
        super().__init__(**kwargs)
        self.p = p

    def apply_transform(self, img):
        rotated = img
        x = len(img.size())-3

        for i in range(x, x+3):
            prob = np.random.rand()
            j = (i + 1)
            if j >= (x+3):
                j -= 3

            if prob < self.p:
                rot_prob = np.random.rand()
                # 90 degree rotation
                if rot_prob < 0.25:
                    rotated = rotated.transpose(i, j).flip(i)
                # 180 degree rotation
                elif rot_prob < 0.5:
                    rotated = rotated.flip(i).flip(j)
                # 270 degree rotation
                elif rot_prob < 0.75:
                    rotated = rotated.transpose(i, j).flip(j)

        return rotated

import torch
import numpy as np

class RandomRotation3D:
    def __init__(self, p=1):
        self.p = p

    def __call__(self, tensor):
        if tensor.dim() not in (3, 4):
            raise ValueError(f"Unexpected tensor shape {tensor.shape}, expected (C, H, W, D) or (H, W, D)")
        if tensor.dim() == 4:  # (C, H, W, D)
            spatial_dims = (1, 2, 3)
        else:  # (H, W, D)
            spatial_dims = (0, 1, 2)

        return self.random_rotate(tensor, spatial_dims)

    def random_rotate(self, tensor, spatial_dims):
        """
        Perform the actual rotation on the spatial dimensions.
        """
        rotated = tensor.clone()  # Copy to avoid modifying in-place

        for i in range(3):  # Iterate over X, Y, Z axes
            if torch.rand(1).item() < self.p:
                j = (i + 1) % 3  # Get the next axis for rotation
                
                rot_prob = torch.rand(1).item()
                # 90-degree rotation
                if rot_prob < 0.25:
                    rotated = rotated.transpose(spatial_dims[i], spatial_dims[j]).flip(spatial_dims[i])
                # 180-degree rotation
                elif rot_prob < 0.5:
                    rotated = rotated.flip(spatial_dims[i]).flip(spatial_dims[j])
                # 270-degree rotation
                elif rot_prob < 0.75:
                    rotated = rotated.transpose(spatial_dims[i], spatial_dims[j]).flip(spatial_dims[j])

        return rotated
